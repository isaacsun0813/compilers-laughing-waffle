(@go
(@go
	0 0
	
	// get user input and initialize an empty array in heap
	call input 0
	rdi <- rax
	rsi <- 1
	call allocate 2
	rdi <- rax
	mem rsp -8 <- :ret
	call @iterate_array 1
	:ret
	

	return	
)

(@iterate_array
	// takes the pointer to the array as arg 1
	1 0	
	
	// since the arr pointer is in rdi, this prints the full array
	mem rsp -8 <- rdi	
	call print 1
	rdi <- mem rsp -8

	// save the length of the array in a caller-saved register
	r10 <- mem rdi 0
	
	// initialize a caller-saved counter to zero
	r11 <- 0
	// initialize another caller-saved for a pointer to the first actual element in the array (not the length)
	r8 <- rdi
	r8 += 8
	
	:FORL
	// exit if length less than or equal to counter	
	cjump r10 <= r11 :ENDL
	// print the contents of each array element
	
	rdi <- 7	
	//rdi @ r8 r11 8
	//rdi <- mem rdi 0
	mem rsp -8 <- r11
	mem rsp -16 <- r10
	mem rsp -24 <- r8	
	call print 1
	r11 <- mem rsp -8
	r10 <- mem rsp -16
	r8 <- mem resp -24
	// increment the counter
	r11++
	// loop back to condition check
	goto :FORL  
	
	:ENDL
	return
)
)
